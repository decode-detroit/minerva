// Copyright (c) 2017-2021 Decode Detroit
// Author: Patton Doyle
// Licence: GNU GPLv3
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! This module implements the update! macro for easy logging in the
//! system interface.'

// Import crate definitions
use crate::definitions::*;

// Import standard library modules
use std::fmt;

/// An enum for logging changes to the game. Most changes in the system interface
/// should go through this enum (and through the logging module).
///
#[derive(PartialEq, Eq, Clone, Debug)]
pub enum LogUpdate {
    /// A variant that notifies the rest of the system to broadcast this
    /// event with optional data.
    Broadcast(ItemId, Option<u32>),

    /// A variant that notifies the rest of the system of a currently playing
    /// event.
    Current(ItemId),

    // Define several event update types, in order of decreasing priority
    /// A variant which passes unrecoverable errors generated by the system.
    Error(String, Option<ItemId>),

    /// A variant that notifies the system logger to log data to the game log
    Save(String), // the data to save, formatted as a string

    /// A variant that notifies the rest of the system of the new state of the status
    Status(ItemId, ItemId), // first field is the status id, second is the new state

    /// A variant which can send any other type of update to the system.
    Update(String),

    /// A variant which passes recoverable warnings generated by the system.
    Warning(String, Option<ItemId>),
}

// Implement displaying that shows detail of the log update
impl fmt::Display for LogUpdate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            // If there is a broadcast event, write the formatted ID
            &LogUpdate::Broadcast(ref event, ..) => write!(f, "Broadcast: {}", event),

            // If there is a current event, write the formatted ID
            &LogUpdate::Current(ref current_event) => write!(f, "Now Playing: {}", current_event),

            // If there is an error, simply write the string
            &LogUpdate::Error(ref error, ..) => write!(f, "ERROR: {}", error),

            // If there is data to save, write it
            &LogUpdate::Save(ref data) => write!(f, "Got Data: {:?}", data),

            // If there is a status change, copy it
            &LogUpdate::Status(ref status_id, ref state) => write!(f, "Status: {} Now {}", status_id, state),

            // If there is a system update, simply write the string
            &LogUpdate::Update(ref update) => write!(f, "Update: {}", update),

            // If there is a warning, simply write the string
            &LogUpdate::Warning(ref warning, ..) => write!(f, "WARNING: {}", warning),
        }
    }
}

/// A macro that allows the user to quickly and easily send status updates over
/// the update line to the rest of the system.
///
macro_rules! update {

    // Take a mpsc line and error type of LogUpdate
    (err $line:expr => $($arg:tt)*) => ({
        // Import necessary features
        use std::fmt::Write;
        use crate::definitions::LogUpdate;

        // Attempt to format the string
        let mut s = String::new();
        s.write_fmt(format_args!($($arg)*)).unwrap_or(());

        // Send the error to the mpsc line
        $line.send_update(LogUpdate::Error(s, None)).await;
    });

    // Take a mpsc line and error type of LogUpdate with an event id
    (errevent $line:expr => $event:expr => $($arg:tt)*) => ({
        // Import necessary features
        use std::fmt::Write;
        use crate::definitions::LogUpdate;

        // Attempt to format the string
        let mut s = String::new();
        s.write_fmt(format_args!($($arg)*)).unwrap_or(());
        
        // Send the error to the mpsc line
        $line.send_update(LogUpdate::Error(s, Some($event))).await;
    });

    // Take a mpsc line and warning type of LogUpdate
    (warn $line:expr => $($arg:tt)*) => ({
        // Import necessary features
        use std::fmt::Write;
        use crate::definitions::LogUpdate;

        // Attempt to format the string
        let mut s = String::new();
        s.write_fmt(format_args!($($arg)*)).unwrap_or(());
        
        // Send the warning to the mpsc line
        $line.send_update(LogUpdate::Warning(s, None)).await;
    });

    // Take a mpsc line and warning type of LogUpdate with an event id
        // Take a mpsc line and warning type of LogUpdate
    (warnevent $line:expr => $event:expr => $($arg:tt)*) => ({
        // Import necessary features
        use std::fmt::Write;
        use crate::definitions::LogUpdate;

        // Attempt to format the string
        let mut s = String::new();
        s.write_fmt(format_args!($($arg)*)).unwrap_or(());
        
        // Send the warning to the mpsc line
        $line.send_update(LogUpdate::Warning(s, Some($event))).await;
    });

    // Take a mpsc line and broadcast type of event update
    (broadcast $line:expr => $event:expr, $data:expr) => ({
        // Import necessary features
        use crate::definitions::LogUpdate;

        // Send an update to the mpsc line
        $line.send_update(LogUpdate::Broadcast($event, $data)).await;
    });

    // Take a mpsc line and current type of event update
    (now $line:expr => $event:expr) => ({
        // Import necessary features
        use crate::definitions::LogUpdate;

        // Send an update to the mpsc line
        $line.send_update(LogUpdate::Current($event)).await;
    });

    // Take a mpsc line and status type of event update
    (status $line:expr => $group_id:expr, $status:expr) => ({
        // Import necessary features
        use crate::definitions::LogUpdate;

        // Send an update to the mpsc line
        $line.send_update(LogUpdate::Status($group_id, $status)).await;
    });

    // Take a mpsc line and save type of event update
    (save $line:expr => $data:expr) => ({
        // Import necessary features
        use crate::definitions::LogUpdate;

        // Send an update to the mpsc line
        $line.send_update(LogUpdate::Save($data)).await;
    });

    // Take a mpsc line and update type of event update
    (update $line:expr => $($arg:tt)*) => ({
        // Import necessary features
        use crate::definitions::LogUpdate;

        // Import the standard library
        use std::fmt::Write;

        // Attempt to format the string
        let mut s = String::new();
        s.write_fmt(format_args!($($arg)*)).unwrap_or(());
        
        // Send the update to the mpsc line
        $line.send_update(LogUpdate::Update(s)).await;
    });
}

// Tests of the update module
#[cfg(test)]
mod tests {
    use super::*;

    // Test the update! macro
    #[tokio::test]
    async fn update_macro() {
        // Import libraries for testing
        use crate::definitions::{InternalSend, InternalUpdate};

        // Create the receiving line
        let (tx, mut rx) = InternalSend::new();

        // Generate a few messages
        update!(err tx => "Test Error {}", 1);
        update!(warn tx => "Test Warning {}", 2);
        update!(broadcast tx => ItemId::new_unchecked(3), None);
        update!(now tx => ItemId::new_unchecked(4));
        update!(update tx => "Test Update {}", "5");

        // Create the test vector
        let test = vec![
            InternalUpdate::Update(LogUpdate::Error("Test Error 1".to_string(), None)),
            InternalUpdate::Update(LogUpdate::Warning("Test Warning 2".to_string(), None)),
            InternalUpdate::Update(LogUpdate::Broadcast(ItemId::new_unchecked(3), None)),
            InternalUpdate::Update(LogUpdate::Current(ItemId::new_unchecked(4))),
            InternalUpdate::Update(LogUpdate::Update("Test Update 5".to_string())),
        ];

        // Print and check the messages received (wait at most half a second)
        test_vec!(=rx, test);
    }
}
