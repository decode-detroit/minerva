// Copyright (c) 2021 Decode Detroit
// Author: Patton Doyle
// Licence: GNU GPLv3
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! This module implements structures shared from the media interface

// Import FNV HashMap
use fnv::FnvHashMap;

/// A struct to hold the dimensions of a video Frame
///
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct VideoFrame {
    pub window_number: u32, // the window number for the channel
    pub top: i32,           // the distance (in pixels) from the top of the display
    pub left: i32,          // the distance (in pixels) from the left of the display
    pub height: i32,        // the height of the video
    pub width: i32,         // the width of the video
}

// A helper struct to define the dimensions of a video window.
//
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VideoFrameHelper {
    pub window_number: u32,
    pub top: i32,
    pub left: i32,
    pub height: i32,
    pub width: i32,
}

// Implement conversion features for VideoFrame
impl VideoFrame {
    pub fn into_helper(self) -> VideoFrameHelper {
        // Return the completed video window helper
        return VideoFrameHelper {
            window_number: self.window_number,
            top: self.top,
            left: self.left,
            height: self.height,
            width: self.width,
        };
    }
}

/// Am enum to specify the type of audio output device
///
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum AudioDevice {
    /// An ALSA audio sink with a device name
    Alsa { device_name: String },

    /// A Pulse Audio sink with a device name
    Pulse { device_name: String },

    /// A Jack Audio sink with no parameters
    Jack,
}

// A helper struct to specify the type of audio output device
//
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum AudioDeviceHelper {
    /// An ALSA audio sink with a device name
    Alsa { device_name: String },

    /// A Pulse Audio sink with a device name
    Pulse { device_name: String },

    /// A Jack Audio sink with no parameters
    Jack,
}

// Implement conversion features for VideoWindow
impl AudioDevice {
    pub fn into_helper(self) -> AudioDeviceHelper {
        // Return the completed audio device helper
        match self {
            AudioDevice::Alsa { device_name } => AudioDeviceHelper::Alsa { device_name },
            AudioDevice::Pulse { device_name } => AudioDeviceHelper::Pulse { device_name },
            AudioDevice::Jack => AudioDeviceHelper::Jack,
        }
    }
}

/// A struct to define a single channel to display a media track
///
/// # Note
///
/// If media is specified in the loop media field, the channel will loop this
/// media when the first media completes and anytime no other media has been
/// directed to play on the channel. If no loop media is specified, the channel
/// will hold on the last frame of the most recent media.
///
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct MediaChannel {
    pub video_frame: Option<VideoFrame>, // the video frame. Defaults to a new window generated by gstreamer
    pub audio_device: Option<AudioDevice>,     // the audio device. Defaults to the system default
    pub loop_media: Option<String>, // the media (video or audio) to loop when no other media is playing
}

// A helper struct to define a single channel to display a media track.
// This version includes the channel number in the struck to allow easier
// passing to apollo.
//
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MediaChannelHelper {
    pub channel: u32,
    pub video_frame: Option<VideoFrameHelper>,
    pub audio_device: Option<AudioDeviceHelper>,
    pub loop_media: Option<String>,
}

// Implement conversion features for Media Channel
impl MediaChannel {
    // Add the channel number to an existing media channel
    pub fn add_number(self, channel: u32) -> MediaChannelHelper {
        // Convert the video window, if specified
        let video_frame = match self.video_frame {
            Some(frame) => Some(frame.into_helper()),
            None => None,
        };

        // Convert the audio device, if specified
        let audio_device = match self.audio_device {
            Some(device) => Some(device.into_helper()),
            None => None,
        };

        // Return the completed media channel helper
        return MediaChannelHelper {
            channel,
            video_frame,
            audio_device,
            loop_media: self.loop_media,
        };
    }
}

/// A type to store a hashmap of channel ids and allocations
///
pub type ChannelMap = FnvHashMap<u32, MediaChannel>;

/// A struct to define an application window to hold one or more media channels
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
pub struct WindowDefinition {
    pub fullscreen: bool, // a flag to indicate whether the window should be fullscreen
    pub dimensions: Option<(i32, i32)>, // the minimum dimensions of the window
}

// A helper struct to define an application window to hold one or more media channels
//
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WindowDefinitionHelper {
    pub window_number: u32,
    pub fullscreen: bool,
    pub dimensions: Option<(i32, i32)>,
}

// Implement conversion features for WindowDefinition
impl WindowDefinition {
    pub fn add_number(self, window_number: u32) -> WindowDefinitionHelper {
        // Return the completed window definition helper
        WindowDefinitionHelper {
            window_number,
            fullscreen: self.fullscreen,
            dimensions: self.dimensions,
        }
    }
}

/// A type to store a hashmap of window ids and parameters
///
pub type WindowMap = FnvHashMap<u32, WindowDefinition>;

/// A struct to hold parameters for Apollo media player
///
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ApolloParams {
    pub spawn: bool, // a flag if Minerva should spawn and manage the Apollo process
    pub address: Option<String>, // the address where Apollo will listen for instructions, defaults to Apollo on localhost
}

/// A scruct to specify all the details of a media player
///
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MediaPlayer {
    pub channel_map: ChannelMap, // the map of channel numbers to channel properties
    pub window_map: WindowMap,   // the map of window numbers to window properties
    pub apollo_params: ApolloParams, // the parameters for Apollo media player, if specified
}

// A helper struct to specify seeking media on a channel
//
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SeekMediaHelper {
    pub channel: u32,  // the channel for the media
    pub position: u64, // the new position within the media stream in milliseconds
}
